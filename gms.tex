% $Id$
% $Log$
% Revision 1.4  2003/03/28 16:47:50  fuhrmann
% pdelib1.15_alpha1
%
% Revision 1.3  2003/03/28 11:20:28  fuhrmann
% pdelib2.0_alpha1
%
% Revision 1.2  2000/03/01 16:45:08  fuhrmann
% color allocation problems appear to be understood
%
% Revision 1.1  1995/10/20  15:24:53  fuhrmann
% Initial revision
%
%
\documentstyle[html]{article}
\title{ GMS - Graphics Minimal System }
\author{J\"{u}rgen Fuhrmann  (fuhrmann@iaas-berlin.d400.de)}
\date{v0.8, 22 April 1994
}
\sloppy


\begin{document}
\maketitle
\begin{abstract}
GMS is a portable interface to different graphical
environments.
\end{abstract}
\tableofcontents

\section{Introduction\label{intro}}The {\em Graphics Minimal System\/} GMS 
provides  a portable interface to different graphical
environments.
This interface should not include all features one
could imagine, but a sufficient set of graphics
routines which could be connected to all the graphics
systems normally used.



It is intended to be used as an on-line graphics tool.
Perfect presentation graphics should be generated by
other tools.
However, postscript protocolling of screen output is 
possible,  and the postscript files are designed to
be used for dvips and  other programs.



{\em GMS\/} has been written in K\&R compatible ANSI-C.
It provides a FORTRAN 77 interface.




\section{Bugs\label{Bugs}}{\em GMS\/} is not the main product of it's authors, so it
has been coded when there has been some time left to do so.
All versions minor to 1.0 should be understood as 
beta releases which probably contain bugs. Some of
the known bugs are listed in the reference pages.
However, the authors and
the current users (beta testers) use {\em GMS\/} successfully
for their purposes, so that it might be useful for others, too.

 
Please, email bug reports and proposals to the authors.
Be aware that the functionality of {\em GMS\/} will 
remain  restricted approximately to the current state
(some mouse support possibly will be added).
At the other hand, drivers can be added rather easily.

If you need a more sophisticated graphics tool
with menu support etc, you probably
should look at other places.








\section{Acknowledgements\label{ack}}The authors of the library are
J\"{u}rgen Fuhrmann  (fuhrmann@iaas-berlin.d400.de)
and 
Hartmut Langmach  (langmach@iaas-berlin.d400.de).
The MSC and OS/2 support has been  contributed by
Ingo Bremer    (bremer@iaas-berlin.400.de).

This code would contain far more bugs than now without the 
permanent beta testers
Ilja Schmelzer (Berlin),  
Klaus G\"{a}rtner (Z\"{u}rich),
Norbert Strecker (Z\"{u}rich),
Rainer N\"{u}rnberg (Berlin).





Some ideas and code fragments 
which have been modified here so that the authors of these
programs  cannot be made responsible for any bugs occuring
in the corresponding parts of {\em GMS\/}  have been taken
from   GNUPLOT (Regis and Tek codes),
GHOSTSCRIPT (generic fonts)
and 
Xlib Programmer's Guide (X11 code).




\section{Overview\label{overview}}In the following, a short overview of the capabilities of GMS
is given. For a detailed description, see the reference pages.




\subsection{Workstation Control\label{control}} 
The workstation concept of GMS has been inherited from GKS.

 
A {\em workstation\/}  is a hidden structure in GMS which contains all
information to establish and to maintain a connection to a file,
physical device or X-window. For FORTRAN compatibility, workstations
are accessed via a handle, the {\em  workstation identifier\/}. 
At one time, there can be open and/or  active several workstations.

GMS works with three categories of workstations:
\begin{description}
 

\item[Window devices.]\mbox{}

 Output is directed into a window on a 
display. 
Text output is not affected.
The 
{\bf gms\_begin} (\ref{gmsbegin}) -
{\bf gms\_end} (\ref{gmsend}) pairs
process some chunks of the event queue.
Currently, these are 
{\bf X11} (\ref{x11}), 
{\bf Iris GL} (\ref{gl}), 
{\bf Sunview} (\ref{sunview}). 
 

\item[File devices.]\mbox{}

 Output is directed into a file. 
Text output is not affected.
For every 
{\bf gms\_begin} (\ref{gmsbegin}) -
{\bf gms\_end} (\ref{gmsend}) pair, there is generated 
a new filename from the filename stub.
Currently, these are 
{\bf Postscript} (\ref{ps}) and
{\bf HPGL} (\ref{hpgl}).
If output is redirected to a file, 
{\bf regis} (\ref{regis})  and 
{\bf tek4014} (\ref{tek4014}) count here, too. 

\item[Console devices]\mbox{}


Text output and graphical output share one screen, so that 
there exists a text and a graphics mode.
The 
{\bf gms\_begin} (\ref{gmsbegin}) -
{\bf gms\_end} (\ref{gmsend}) pairs
do the necessary mode switching.
These are at present time
{\bf regis} (\ref{regis}),
{\bf tek4014} (\ref{tek4014}),
{\bf BGI} (\ref{bgi}) and 
{\bf Microsoft C} (\ref{msc}). 
\end{description}






The basic control routines of GMS mainly consist of 
two bracketing pairs:
\begin{itemize}
\item  
{\bf gms\_open} (\ref{gmsopen}) and
{\bf gms\_close} (\ref{gmsclose}) which open and
close workstations. 
          
\item  
{\bf gms\_begin} (\ref{gmsbegin}) and
{\bf gms\_end} (\ref{gmsend}) which activate and
deactivate  workstations.
\end{itemize}
 

They set up the frame of any program using GMS.

Further, there are the following control
routines:
\begin{itemize}
\item  
{\bf gms\_clear} (\ref{gmsclear}) 
to clear a workstation.
\item  
{\bf gms\_flush} (\ref{gmsflush}) 
to flush the graphics output. Many graphical devices collect the
output requests into larger chunks which can be more effectively
processed by the hardware.
\item  
{\bf gms\_hold} (\ref{gmshold}) 
to flush and hold the graphics output. It can be used mainly in programs
which have no control language or on devices sharing ascii and
graphics output.
\end{itemize}
 




\subsection{Transformations\label{tran}} 
The transformation concept of GMS is a very simplified version of
the concept of GKS.

There are existing three coordinate systems:
\begin{itemize}
\item The 2D world coordinates. Using 
{\bf gms\_window} (\ref{gmswindow}) 
the user is able to specify a window in this coordinate system.
All 2D output primitive use these coordinates.
\item The 3D world coordinates. Using 
{\bf gms3\_window} (\ref{gms3window}) and
{\bf gms3\_perspective} (\ref{gms3perspective}) 
the user is able to specify a window and a perspective
direction within this coordinate system.
All 3D output primitive use these coordinates.
 
\item The normalized 2D device  coordinates.
The range $ [0,1] \times [0,1] $ of these coordinates
is the maximal range on the output device which is
accessed by GMS. 
Using   
{\bf gms\_viewport} (\ref{gmsviewport})
this range can be shrinked for 2D output primitives.
A corresponding 3D coordinate system does not exist, 
because it's support on Iris GL would make a lot 
of trouble.
\end{itemize}





\subsection{Color Handling\label{Color}}There are three ways GMS handles colors.


\subsubsection{The Internal Color Map\label{defcolor}}Using 
{\bf gms\_setcolor} (\ref{gmssetcolor})
and
{\bf gms\_defcolor} (\ref{gmsdefcolor})
one is able to select a color from the internal color map
and to specify its representation. Subsequent output
of the simple output primitives 
as 
{\bf gms\_lineto} (\ref{gmslineto}),
{\bf gms\_text} (\ref{gmstext}),
{\bf gms\_fill} (\ref{gmsfill})
is done using this color.

The size of this internal colormap can be queried by 
{\bf gms\_querycolors} (\ref{gmsquerycolors}).








\subsubsection{Color Scales\label{defcolorsc}} 
The complex output primitives 
{\bf gms\_shaded\_triangle} (\ref{gmsshadedtriangle}) and
{\bf gms3\_shaded\_triangle} (\ref{gmsshadedtriangle})
use a color scale which can 
be defined by 
{\bf gms\_setcolorscale} (\ref{gmssetcolorscale}) as
a piecewise linear relationship of function and rgb values.

Depending on the capabilities of the workstation, this 
scale is used for Gouraud shading or its emulation.




\subsubsection{Light model\label{lightmod}} 
The complex output primitive
{\bf gms3\_triangle} (\ref{gmsshadedtriangle})
uses a light model which may overwrite any internal
color maps and scales.
In a future version, there should be implemented
the possibility to specify some parameters of this model.




\subsection{Output Primitives\label{Outprim}}

\subsubsection{2D Simple Output Primitives\label{2Dsimp}}The simple output primitives in 2D are:
\begin{itemize}
\item 
{\bf gms\_moveto} (\ref{gmsmoveto})
moves the actual position  to the specified coordinates.
\item 
{\bf gms\_lineto} (\ref{gmslineto})
moves the actual position point to the specified coordinates
and draws a line.
\item 
{\bf gms\_marker} (\ref{gmsmarker})
puts a maker of the specified kind
at the 
actual position.
\item 
{\bf gms\_text} (\ref{gmstext})
puts text at the actual position which is aligned
according to the data specified by
{\bf gms\_aligntext} (\ref{gmsaligntext})
\item 
{\bf gms\_polyline} (\ref{gmspolyline})
draws a polyline (without using or affecting the actual position).
\item 
{\bf gms\_fill} (\ref{gmsfill})
fill an area (without using or affecting the actual position).
There is no way to specify a fill pattern.
\end{itemize}

All output of these routines appears in the current
color.




\subsubsection{2D Complex Output Primitives\label{2Dcomp}}The complex output primitives use as a basic data structure
a triangle and a linear function defined by its
node values  which is rendered in various fashions.

\begin{itemize}
\item  
{\bf gms\_shaded\_triangle} (\ref{gmsshadedtriangle})
draws a Gouraud shaded triangle using the current color scale.
\item  
{\bf gms\_isoline\_triangle} (\ref{gmsisolinetriangle})
draws a triangle with the isolines of a function using the 
current level map.
\end{itemize}





\subsubsection{3D Simple Output Primitives\label{3Dsimp}}There are currently only 
three  simple output primitives in 3D:
\begin{itemize}
\item 
{\bf gms3\_moveto} (\ref{gms3moveto})
Moves the actual position  to the specified coordinates.
\item 
{\bf gms3\_lineto} (\ref{gms3lineto})
Moves the actual position point to the specified coordinates
and draws a line.
\item 
{\bf gms3\_text} (\ref{gms3text})
Put unaligned text at current position.  
\end{itemize}



\subsubsection{ 3D Complex Output Primitives\label{3Dcomp}}The complex output primitives use as a basic data structure
a triangle and possibly, a linear function defined by its
node values  which is rendered in various fashions.

\begin{itemize}
\item  
{\bf gms3\_triangle} (\ref{gms3triangle})
draws a  triangle using a light model.
\item  
{\bf gms3\_shaded\_triangle} (\ref{gms3shadedtriangle})
draws a Gouraud shaded triangle using the current color scale.
\end{itemize}









\section{Installation\label{Installation}}The whole source code of {\em GMS\/}  is contained in
{\em gms.c\/}. This file is a concatenation of  the 
driver sources.
See the
{\bf Wizard's Guide for Writing GMS Drivers}
 which 
might be written once in the future for more information.

The installation just consists in compiling this source
with the appropriate 
{\bf compiler flags} (\ref{Comp}).
These flags are mainly used to select the drivers you wish to use.
When nothing is specified, a default set of drivers is compiled
which doesn't need any furthe library.
After this you can link the object file with your program and
the necessary system libraries.

Below, some specific notes are given.




\subsection{UNIX Systems\label{UNIXSystems}}For the UNIX installation, you can use the {\tt Makefile} which 
comes along with the distribution which you should edit  for your needs.

{\em GMS\/} should compile with any C compiler.
If your cc does not support prototyping, specify {\tt -DNOPROTO}
at the command line.




\subsection{VMS Systems\label{VMSSystems}}{\em GMS\/} should compile under VMS (both VAX and AXP).
The only tricky thing is how you link with the shared libraries for X11.
See {\tt vmsinstall.com} for the details.

When you need to specify compiler flags, you can do this by
specifying {\tt cc /define=xxx } which has the UNIX
equivalent {\tt cc -Dxxx}.




\subsection{Fortran\label{instFortran}}For a description of the Fortran interface, see 
{\bf Fortran Interface} (\ref{Fortran}).

Here is a list of tricky things you shold care about:
\begin{description}
\item[REAL*4 vs. REAL*8]\mbox{}

 The Fortran interface
can be generated for both cases by specifying
{\tt -DREAL4} on the command line.
\item[INTEGER*4]\mbox{}

 all integers passed to {\em GMS\/} are of type
INTEGER*4.
\item[CHARACTER]\mbox{}

 Character strings can be passed to {\em GMS\/}
when you terminate them with '\verb+\+0'. So,
you should write 
\begin{verbatim}
 call gmtext('Eat my shorts, man !\verb+\+0')
\end{verbatim}
 
instead of
\begin{verbatim}
 call gmtext('Eat my shorts, man !').
\end{verbatim}
 
                     
The  '\verb+\+0' terminator is parsed by {\em GMS\/},
so that even in the case that it is not recognized by the Fortran    
compiler things go well.
Under VMS, first, the string descriptor is analyzed.

Thus, the necessary Fortran verb should be portable.

{\bf Caution!}
\begin{verbatim}
call gmtext('Eat my shorts,'//' man !\verb+\+0')
\end{verbatim}
 probably
doesn't work, so it might be necessary to use an interim
character variable to assemble the string.

\item[External symbols]\mbox{}

 
There are different ways, Fortran generates external
symbols - in upper or lower case and with or without
underscores. You should examine your system for this 
feature and use the appropriate 
{\bf compiler flag} (\ref{Comp}).
\item[Linking]\mbox{}

 
This is the most tricky thing. Under VMS, there
should be no trouble. 
On UNIX, you should be 
on the safe side when you link with the Fortran compiler
and your main program is in Fortran. A main program in C
on DEC systems made trouble. Linking with ld or the
C compiler
is not recommended  because no one knows which 
libraries f77  uses (try f77 -v to get an impression). 

\end{description}



\newpage



\section{Reference Pages}\label{refpages}
\subsection{2D Routines}\label{2Drefpages}

\subsubsection{gms\_open\label{gmsopen}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_open (int  ws, int driver, char *options)\/}
\item[Purpose]\mbox{}


Open and initialize workstation.
Text output remains possible. 
\item[Description]\mbox{}


\begin{description}
\item[{\em ws\/}]\mbox{}

 Workstation identifier.
\item[{\em driver\/}]\mbox{}

 Driver number. For a possible numbers and
their preprocessor defines
see 
{\bf Drivers} (\ref{DRefpages})
\item[{\em options\/}]\mbox{}

 Option string. 
If an option does make no sense for
a driver it is ignored. The following options
are currently implemented:
\begin{description}
      
\item[     -O fname]\mbox{}

  Output file name stub  
\item[     -D dname]\mbox{}

 X11 Display name
\item[     -T tname]\mbox{}

 Window title
\item[     -H ysize]\mbox{}

 Window height 
\item[     -W xsize]\mbox{}

 Window width
\item[     -B colname]\mbox{}

 Window Background color
\item[    -F fontname]\mbox{}

 
X11 or Postscript font name
                    
\end{description}
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_close} (\ref{gmsclose}), 
{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsclose}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_querystate} (\ref{gmsquerystate}),
\item[Bugs]\mbox{}


The option processor is very customary.
\end{description}





\newpage



\subsubsection{gms\_close\label{gmsclose}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_close (int  ws)\/}
\item[Purpose]\mbox{}


Close workstation an free all internal memory.
\item[Description]\mbox{}


\begin{description}
\item[{\em ws\/}]\mbox{}

 Workstation identifier.
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_close} (\ref{gmsclose}), 
{\bf gms\_end} (\ref{gmsend}),
{\bf gms\_querystate} (\ref{gmsquerystate})
\item[Bugs]\mbox{}


Check if really all memory is freed. 
\end{description}





\newpage



\subsubsection{gms\_begin\label{gmsbegin}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_begin (int  ws)\/}
\item[Purpose]\mbox{}


Enable  graphical output for a new ``picture''.
On window devices, do processing of qeued events.
On file devices, open a new  file with automatically generated name.
For console devices, disable text output and enter graphics mode.
\item[Description]\mbox{}


\begin{description}
\item[{\em ws\/}]\mbox{}

 Identifier of the workstation to be activated.
If {\em ws\/} is $-1$, all open workstations
are affected. 
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf gms\_close} (\ref{gmsclose}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_querystate} (\ref{gmsquerystate}),
{\bf Control} (\ref{control})
\end{description}





\newpage



\subsubsection{gms\_end\label{gmsend}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_end (int  ws)\/}
\item[Purpose]\mbox{}


If the workstation is in 3D mode and there is no
graphics hardware, process and flush the collected 3D data.
Disable graphical output.

On window devices, do processing of qeued events.
On file devices, close the actual output
file.
For console devices, switch to text  mode.

\item[Description]\mbox{}


\begin{description}
\item[{\em ws\/}]\mbox{}

 Identifier of the workstation to be activated.
If {\em ws\/} is $-1$, all active workstations
are affected. 
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf gms\_close} (\ref{gmsclose}), 
{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_querystate} (\ref{gmsquerystate}),
{\bf Control} (\ref{control})
\end{description}



\newpage



\subsubsection{gms\_querystate\label{gmsquerystate}}
\begin{description}
\item[Synopsis]\mbox{}


{\em int   gms\_querystate(int ws)\/}
\item[Purpose]\mbox{}


Inquire the state of a workstation.
Possible return values are:
\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol& Value& Description\\ 
GMS\_STATE\_CLOSED & 0 &  gms\_open not called or failed\\ 
GMS\_STATE\_OPEN & 1 &  between gms\_open and gms\_close\\ 
GMS\_STATE\_ACTIVE & 2 &  between gms\_begin and gms\_end\\ 
\hline\end{tabular}
\end{center}

\item[Description]\mbox{}


\begin{description}
\item[{\em ws\/}]\mbox{}

 Workstation number.
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_close} (\ref{gmsclose}), 
{\bf gms\_end} (\ref{gmsend})
\end{description}


\newpage



\subsubsection{gms\_flush\label{gmsflush}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_flush (void)\/}
\item[Purpose]\mbox{}


Flush graphical output.
\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_clear} (\ref{gmsclear}), 
{\bf gms\_hold} (\ref{gmshold}), 
{\bf Control} (\ref{control})
\end{description}





\newpage



\subsubsection{gms\_hold\label{gmshold}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_hold (void)\/}
\item[Purpose]\mbox{}


Flush graphical output and wait for pressing the 
return key.
\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_clear} (\ref{gmsclear}),  
{\bf gms\_flush} (\ref{gmsflush}), 
{\bf Control} (\ref{control})
\end{description}



\newpage



\subsubsection{gms\_clear\label{gmsclear}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_clear (void)\/}
\item[Purpose]\mbox{}


Clear graphical output.
\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_clear} (\ref{gmsclear}), 
{\bf gms\_flush} (\ref{gmsflush}), 
{\bf Control} (\ref{control})
\item[Bugs]\mbox{}


On file devices, the result is undefined, there should be some
clear behaviour.
\end{description}



\newpage



\subsubsection{gms\_window\label{gmswindow}}
\begin{description}
\item[Synopsis]\mbox{}


{\em  void    gms\_window(double xmin,
double xmax,
double ymin,
double ymax);\/}
\item[Purpose]\mbox{}


Define the window in  the world coordinate system 
which is mapped onto the graphical device.
This call puts the workstation into 2D mode.



\item[Description]\mbox{}


\begin{description}
\item[{\em xmin\/}]\mbox{}

 minimal x coordinate
\item[{\em xmax\/}]\mbox{}

 maximal x coordinate
\item[{\em ymin\/}]\mbox{}

 minimal y coordinate
\item[{\em ymax\/}]\mbox{}

 maximal y coordinate
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_viewport} (\ref{gmsviewport}), 
\item[Bugs]\mbox{}


The aspect ratio handling of the transformations is not very clear.
The should be a gms\_keepaspect call which enables the user
to choose one of two well defined kinds of behaviour.
 
The best results are reached when both window and viewport have
aspect ratio 1.

 Obviously, this problem should be fixed with high priority.

\end{description}



\newpage



\subsubsection{gms\_viewport\label{gmsviewport}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_viewport(double xmin,
double xmax,
double ymin,
double ymax);\/}
\item[Purpose]\mbox{}


Define the viewport in  the normalized device  coordinate system.
\item[Description]\mbox{}


\begin{description}
\item[{\em xmin\/}]\mbox{}

 minimal x coordinate
\item[{\em xmax\/}]\mbox{}

 maximal x coordinate
\item[{\em ymin\/}]\mbox{}

 minimal y coordinate
\item[{\em ymax\/}]\mbox{}

 maximal y coordinate
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_window} (\ref{gmswindow}), 
\item[Bugs]\mbox{}


The aspect ratio handling of the transformations is not very clear.
The should be a gms\_keepaspect call which enables the user
to choose one of two well defined kinds of behaviour.
 
The best results are reached when both window and viewport have
aspect ratio 1.

 Obviously, this problem should be fixed with high priority.

\end{description}



\newpage



\subsubsection{gms\_moveto\label{gmsmoveto}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_moveto(double x, double y)\/}
\item[Purpose]\mbox{}


Move the internal position (``pen'') to the point $(x,y)$.
\item[Description]\mbox{}


\begin{description}
\item[{\em x\/}]\mbox{}

 x coordinate (in world coordinates)
\item[{\em y\/}]\mbox{}

 y coordinate (in world coordinates)
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_lineto} (\ref{gmslineto}), 
{\bf gms\_polyline} (\ref{gmspolyline}), 
\end{description}


\newpage



\subsubsection{gms\_lineto\label{gmslineto}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_lineto(double x, double y)\/}
\item[Purpose]\mbox{}


Draw a line to the point $(x,y)$ in the  current color and
move the internal position (``pen'') to this point.
\item[Description]\mbox{}


\begin{description}
\item[{\em x\/}]\mbox{}

 x coordinate (in world coordinates)
\item[{\em y\/}]\mbox{}

 y coordinate (in world coordinates)
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_moveto} (\ref{gmsmoveto}), 
{\bf gms\_polyline} (\ref{gmspolyline}), 
\end{description}





\newpage



\subsubsection{gms\_text\label{gmstext}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_text(char * text)\/}
\item[Purpose]\mbox{}


Put text in the  current color at the current pen position using the current
alignment setting. 
\item[Description]\mbox{}


\begin{description}
\item[{\em text\/}]\mbox{}

 character string containing text
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_moveto} (\ref{gmsmoveto}), 
{\bf gms\_aligntext} (\ref{gmsaligntext}), 
{\bf Font Handling} (\ref{fonts}), 
\end{description}





\subsubsection{gms\_aligntext\label{gmsaligntext}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_aligntext(int xalign,  int yalign)\/}
\item[Purpose]\mbox{}


Define text alignment with respect to pen position
for subsequent text output. 
\item[Description]\mbox{}


\begin{description}

\item[{\em xalign\/}]\mbox{}

 Horizontal alignment. Possible values are:

\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value\\ 
\hline
GMS\_ALIGN\_LEFT & 1 \\ 
GMS\_ALIGN\_RIGHT & 2 \\ 
GMS\_ALIGN\_CENTER & 3 \\ 
\hline\end{tabular}
\end{center}


\item[{\em yalign\/}]\mbox{}

 Vertical alignment. Possible values are:
\begin{center}
\begin{tabular}{ll}\hline
Preprocessor Symbol & Value\\ 
\hline
GMS\_ALIGN\_BOTTOM & 1 \\ 
GMS\_ALIGN\_TOP & 2 \\ 
GMS\_ALIGN\_CENTER & 3 \\ 
\hline\end{tabular}
\end{center}
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_moveto} (\ref{gmsmoveto}), 
{\bf gms\_text} (\ref{gmstext}), 
\end{description}



\newpage



\subsubsection{gms\_marker\label{gmsmarker}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_marker(int mktype)\/}
\item[Purpose]\mbox{}


Put marker in the  current color at the current pen position.
\item[Description]\mbox{}


\begin{description}
\item[{\em mktype\/}]\mbox{}

 Kind of marker. Possible values are:
\begin{center}
\begin{tabular}{ll}\hline
Preprocessor Symbol & Value\\ 
\hline
GMS\_MARKER\_PIXEL & 0\\ 
GMS\_MARKER\_DIAMOND & 1\\ 
GMS\_MARKER\_PLUS & 2\\ 
GMS\_MARKER\_X & 3\\ 
GMS\_MARKER\_ASTERISK & 4\\ 
GMS\_MARKER\_UPARROW & 11\\ 
GMS\_MARKER\_DOWNARROW & 12\\ 
GMS\_MARKER\_LEFTARROW & 13\\ 
GMS\_MARKER\_RIGHTARROW& 14\\ 
\hline\end{tabular}
\end{center}
    
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms\_moveto} (\ref{gmsmoveto}), 
\end{description}



\newpage



\subsubsection{gms\_polyline\label{gmspolyline}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_polyline(int n, double *x, double *y)\/}
\item[Purpose]\mbox{}


Draw a polyline in the  current color with starting point $(x[0],y[0]$ and
ending point $(x[n],y[n]$.
The pen position is not affected.
\item[Description]\mbox{}


\begin{description}
\item[{\em n\/}]\mbox{}

 number of value pairs
\item[{\em x\/}]\mbox{}

 pointer to x coordinates (in world coordinates)
\item[{\em y\/}]\mbox{}

 pointer to y coordinates (in world coordinates)
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
\end{description}


\newpage



\subsubsection{gms\_fill\label{gmsfill}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_fill(int n, double *x, double *y)\/}
\item[Purpose]\mbox{}


Fill the area defined by the (not necessarily closed) 
polyline
with starting point $(x[0],y[0]$ and
ending point $(x[n],y[n]$ with the current color.
The pen position is not affected.
\item[Description]\mbox{}


\begin{description}
\item[{\em n\/}]\mbox{}

 number of value pairs
\item[{\em x\/}]\mbox{}

 pointer to x coordinates (in world coordinates)
\item[{\em y\/}]\mbox{}

 pointer to y coordinates (in world coordinates)
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
\item[Bugs]\mbox{}


Currently, there is a maximal internal buffer size 
{\bf FILLSIZE} (\ref{Comp}) (default value 64) 
which  has to be  specified at compile time.
There should be a mechanism which automatically resizes the 
buffer when necessary.
\end{description}



\newpage



\subsubsection{gms\_shaded\_triangle\label{gmsshadedtriangle}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_shaded\_triangle(double *x, double *y, double *f)\/}
\item[Purpose]\mbox{}


Draw a Gouraud shaded triangle. The color is defined by
the values of {\em f\/} and the current color scale.
The pen position is not affected.
On devices with no hardware capabilities for this operation,
isolines of the function are calculated which divide the 
triangle into different level regions. After this, these 
level regions are filled using the corresponding color.
\item[Description]\mbox{}


\begin{description}
\item[{\em x\/}]\mbox{}

 pointer to x coordinates (in world coordinates)
\item[{\em y\/}]\mbox{}

 pointer to y coordinates (in world coordinates)
\item[{\em f\/}]\mbox{}

 pointer to function values
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend})
{\bf gms\_setcolorscale} (\ref{gmssetcolorscale})
\item[Bugs]\mbox{}


When emulating Gouraud shading the way described above,
it might be better to give the user the possibility 
to configure the number of isolevels used. Currently this
is done by a compile time constant.
After all, is there a better way to do   this job ?

\end{description}





\newpage



\subsubsection{gms\_isoline\_triangle\label{gmsisolinetriangle}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_isoline\_triangle(double *x, double *y, double *f)\/}
\item[Purpose]\mbox{}


Draw  triangle with isolines defined by {\em f\/} and the 
current level map using the current color.
The pen position is not affected.
\item[Description]\mbox{}


\begin{description}
\item[{\em x\/}]\mbox{}

 pointer to x coordinates (in world coordinates)
\item[{\em y\/}]\mbox{}

 pointer to y coordinates (in world coordinates)
\item[{\em f\/}]\mbox{}

 pointer to function values
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}),
{\bf gms\_setisolevels} (\ref{gmssetisolevels})
\item[Bugs]\mbox{}


{\em gms\_isoline\_triangle\/} possibly should define the color 
of the isolines using the current color scale. 
\end{description}



\newpage



\subsubsection{gms\_setisolevels\label{gmssetisolevels}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_setisolevels(int n, 
double *v)\/}
\item[Purpose]\mbox{}


Define a level map for isoline output.
\item[Description]\mbox{}


\begin{description}
\item[{\em n\/}]\mbox{}

 Size of color scale. Minimum is 2. 
\item[{\em v\/}]\mbox{}

 Level values.
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_isoline\_triangle} (\ref{gmsisolinetriangle}), 
\end{description}



\newpage



\subsubsection{gms\_setcolor\label{gmssetcolor}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_setcolor(int color)\/}
\item[Purpose]\mbox{}


Select actual color.
\item[Description]\mbox{}


\begin{description}
\item[{\em color\/}]\mbox{}

 Number of actual color. 
The maximum number of colors available is
workstation dependent and has to be queried.
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_defcolor} (\ref{gmsdefcolor}), 
{\bf gms\_querycolors} (\ref{gmsquerycolors}), 
{\bf gms\_setcolorscale} (\ref{gmssetcolorscale}), 
{\bf Color Handling} (\ref{Color})
\end{description}



\newpage



\subsubsection{gms\_defcolor\label{gmsdefcolor}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_defcolor(double r,double g, double b)\/}
\item[Purpose]\mbox{}


Define the representation of the actual color.
This representation is not affected by subsequent calls of
{\bf gms\_setcolor} (\ref{gmssetcolor}).
\item[Description]\mbox{}


\begin{description}
\item[{\em r\/}]\mbox{}

 fraction of red (between 0 and 1) 
\item[{\em g\/}]\mbox{}

 fraction of green (between 0 and 1) 
\item[{\em b\/}]\mbox{}

 fraction of blue (between 0 and 1) 
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_setcolor} (\ref{gmssetcolor}), 
{\bf gms\_setcolorscale} (\ref{gmssetcolorscale}),
{\bf Color Handling} (\ref{Color})
\item[Bugs]\mbox{}


The color representation  {\em is\/} affected by  
{\bf gms\_setcolorscale} (\ref{gmssetcolorscale}),
which can overwrite all color representations. 
\end{description}



\newpage



\subsubsection{gms\_querycolors\label{gmsquerycolors}}
\begin{description}
\item[Synopsis]\mbox{}


{\em int   gms\_querycolors(int iws)\/}
\item[Purpose]\mbox{}


Inquire the number of colors available.
\item[Description]\mbox{}


\begin{description}
\item[{\em ws\/}]\mbox{}

 Workstation number.
If $ws=-1$, then the minimum over all active
workstation is returned.
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_setcolor} (\ref{gmssetcolor}), 
{\bf gms\_setcolorscale} (\ref{gmssetcolorscale}), 
{\bf Color Handling} (\ref{Color})
\end{description}



\newpage



\subsubsection{gms\_setcolorscale\label{gmssetcolorscale}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms\_setcolorscale(int n, double *r, double *g, double *b,
double *v)\/}
\item[Purpose]\mbox{}


Define a color scale for Gouraud shaded triangle output.
This table is used to look up the interval to which belongs a 
given function value and to interpolate then the color values.
\item[Description]\mbox{}


\begin{description}
\item[{\em n\/}]\mbox{}

 Size of color scale. Minimum is 2. 
\item[{\em r\/}]\mbox{}

 Values of red fraction.
\item[{\em g\/}]\mbox{}

 Values of green fraction.
\item[{\em b\/}]\mbox{}

 Values of blue fraction.
\item[{\em v\/}]\mbox{}

 Function values.
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_defcolor} (\ref{gmsdefcolor}), 
{\bf gms\_setcolor} (\ref{gmssetcolor}), 
{\bf Color Handling} (\ref{Color})
\item[Bugs]\mbox{}

 
After a call to {\em gms\_setcolorscale\/}, the color values
specified by {\em gms\_defcolor\/} may be undefined.
Possibly, there should be different value spaces.
\end{description}



\newpage



\subsection{3D routines \label{3Drefpages}}

\subsubsection{gms3\_window\label{gms3window}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms3\_window(double xmin,
double xmax,
double ymin,
double ymax,double zmin,double zmax);\/}
\item[Purpose]\mbox{}


Define the window in  the 3D world coordinate system 
which is oriented the follwing way:
The x axis is aligned with the screen x axis. 
The z axis is aligned with the screen y axis (looking to the top).
The y axis is aligned with the screen z axis (``into'' the screen).
The reason for this is the way one normally looks at representations
of functions over 2D domains.
On devices with 3D hardware, the hardware transformations are used.
This call puts the workstation into 3D mode.

There is no {\em gms3\_viewport\/}

The workstation has to be in 3D mode.

\item[Description]\mbox{}


\begin{description}
\item[{\em xmin\/}]\mbox{}

 minimal x coordinate
\item[{\em xmax\/}]\mbox{}

 maximal x coordinate
\item[{\em ymin\/}]\mbox{}

 minimal y coordinate
\item[{\em ymax\/}]\mbox{}

 maximal y coordinate
\item[{\em ymin\/}]\mbox{}

 minimal z coordinate
\item[{\em ymax\/}]\mbox{}

 maximal z coordinate
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms3\_perspective} (\ref{gms3perspective}), 
\item[Bugs]\mbox{}


There should be a more transparent way of transformation handling.
May be {\em gms3\_setmatrix\/} ?
May be, switching to the 3D mode has to be done more transparently.

\end{description}


\newpage



\subsubsection{gms3\_perspective\label{gms3perspective}}
\begin{description}
\item[Synopsis]\mbox{}


{\em  void    gms\_perspective(double alpha, double beta);\/}
\item[Purpose]\mbox{}


Define the perspective direction of the  3D projection.
This call puts the workstation into 3D mode.

\item[Description]\mbox{}


\begin{description}
\item[{\em alpha\/}]\mbox{}

 The angle between negative y axis and perspective line
in the plane $z=0$ in degrees. Thus, alpha=0 means that one
looks ``from the front'' as one normally draws a 
xyz coordinate system.
\item[{\em beta\/}]\mbox{}

 
The angle between negative y axis and perspective line
in the plane $x=0$ in degrees.
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms3\_window} (\ref{gms3window}), 
\item[Bugs]\mbox{}


There should be the possibility to define different kinds
of perspectives.
 
Document this more clearly.

\end{description}





\newpage



\subsubsection{gms3\_moveto\label{gms3moveto}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms3\_moveto(double x, double y, double z)\/}
\item[Purpose]\mbox{}


Move the internal 3D position (``pen'') to the point $(x,y,z)$.
\item[Description]\mbox{}


\begin{description}
\item[{\em x\/}]\mbox{}

 x coordinate (in 3D world coordinates)
\item[{\em y\/}]\mbox{}

 y coordinate (in 3D world coordinates)
\item[{\em y\/}]\mbox{}

 z coordinate (in 3D world coordinates)
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms3\_lineto} (\ref{gms3lineto}),
\end{description}


\newpage



\subsubsection{gms3\_lineto\label{gms3lineto}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms3\_lineto(double x, double y, double z)\/}
\item[Purpose]\mbox{}


Draw a line to the point $(x,y,z)$ in the  current color and
move the internal 3D  position (``pen'') to this point.
No hidden line removal is done.
\item[Description]\mbox{}


\begin{description}
\item[{\em x\/}]\mbox{}

 x coordinate (in 3D world coordinates)
\item[{\em y\/}]\mbox{}

 y coordinate (in 3D world coordinates)
\item[{\em y\/}]\mbox{}

 z coordinate (in 3D world coordinates)
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms3\_moveto} (\ref{gms3moveto}),
\end{description}


\newpage





\subsubsection{gms3\_text\label{gms3text}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms3\_text(char * text)\/}
\item[Purpose]\mbox{}


Put text in the  current color at the current 3D pen position.
There is no way to align it.
\item[Description]\mbox{}


\begin{description}
\item[{\em text\/}]\mbox{}

 character string containing text
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend}), 
{\bf gms3\_moveto} (\ref{gms3moveto}), 
{\bf Font Handling} (\ref{fonts}), 
\end{description}





\newpage



\subsubsection{gms3\_triangle\label{gms3triangle}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms3\_triangle(double *x, double *y, double *z);\/}
\item[Purpose]\mbox{}


Draw a  shaded triangle in 3D. The color is defined by
a lighting model.
The pen position is not affected.
On devices with no hardware capabilities for this operation,
first, all triangles are collected.
When 
{\bf gms\_end} (\ref{gmsend})
is invoked, they are sorted and rendered.

\item[Description]\mbox{}


\begin{description}
\item[{\em x\/}]\mbox{}

 pointer to x coordinates (in 3D world coordinates)
\item[{\em y\/}]\mbox{}

 pointer to y coordinates (in 3D world coordinates)
\item[{\em y\/}]\mbox{}

 pointer to z coordinates (in 3D world coordinates)
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend})
{\bf gms\_setcolorscale} (\ref{gmssetcolorscale})
\item[Bugs]\mbox{}


It should be possible to specify the light model.
\end{description}



\newpage



\subsubsection{gms3\_shaded\_triangle\label{gms3shadedtriangle}}
\begin{description}
\item[Synopsis]\mbox{}


{\em void    gms3\_shaded\_triangle(double *x, double *y, double *z, double *f)\/}
\item[Purpose]\mbox{}


Draw a Gouraud shaded triangle in 3D. The color is defined by
the values of {\em f\/} and the current color scale.
The pen position is not affected.
On devices with no hardware capabilities for this operation,
first, all triangles are collected.
When 
{\bf gms\_end} (\ref{gmsend})
is invoked, they are sorted and rendered 
in the following way:
Isolines of the function are calculated which divide the 
triangle into different level regions. After this, these 
level regions are filled using the corresponding color.

\item[Description]\mbox{}


\begin{description}
\item[{\em x\/}]\mbox{}

 pointer to x coordinates (in 3D world coordinates)
\item[{\em y\/}]\mbox{}

 pointer to y coordinates (in 3D world coordinates)
\item[{\em y\/}]\mbox{}

 pointer to z coordinates (in 3D world coordinates)
\item[{\em f\/}]\mbox{}

 pointer to function values
\end{description}

\item[Related Information]\mbox{}


{\bf gms\_begin} (\ref{gmsbegin}), 
{\bf gms\_end} (\ref{gmsend})
{\bf gms\_setcolorscale} (\ref{gmssetcolorscale}) 
\item[Bugs]\mbox{}


When emulating Gouraud shading the way described above,
it might be better to give the user the possibility 
to configure the number of isolevels used. Currently this
is done by a compile time constant.
After all, is there a better way to do   this job ?

\end{description}



\newpage



\subsection{Drivers\label{DRefpages}}

\subsubsection{GMS\_DRIVER\_DEFAULT\label{default}}
\begin{description}
\item[Purpose]\mbox{}


Use default driver defined by
environment symbol  
{\bf GMSDEVICE} (\ref{Env}).
\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_DEFAULT & 0 & \\ 
\hline\end{tabular}
\end{center}
\end{description}


\newpage



\subsubsection{GMS\_DRIVER\_REGIS\label{regis}}
\begin{description}
\item[Purpose]\mbox{}


Draw on regis terminals via stdout. 
\item[Minor Modes]\mbox{}


\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_REGIS &  20& Monochrome\\ 
GMS\_DRIVER\_REGIS\_4COLORS &  21& \\ 
GMS\_DRIVER\_REGIS\_8COLORS &  22&  \\ 
GMS\_DRIVER\_REGIS\_16COLORS &  23&  \\ 
GMS\_DRIVER\_REGIS\_16FREECOLORS&  24& VT340\\ 
\hline\end{tabular}
\end{center}

\item[Options]\mbox{}


-O outputfile
\item[Libraries]\mbox{}


none
\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf Workstation Control} (\ref{control}), 
{\bf Compile Time Constants} (\ref{Comp}), 
{\bf Installation} (\ref{Installation}) 
\item[Bugs]\mbox{}


not so much.
\end{description}





\newpage



\subsubsection{GMS\_DRIVER\_TEK4014\label{tek4014}}
\begin{description}
\item[Purpose]\mbox{}


Draw on tek4014 terminals via stdout. These  are monochrome devices.
Works also with emulators (vt2*, xterm, kermit).
\item[Minor Modes]\mbox{}


\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_TEK4014 &  30& Original tek4014\\ 
GMS\_DRIVER\_TEK4014\_EMU &  31& other devices\\ 
\hline\end{tabular}
\end{center}

\item[Options]\mbox{}


-O outputfile
\item[Libraries]\mbox{}


none
\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf Workstation Control} (\ref{control}), 
{\bf Compile Time Constants} (\ref{Comp}), 
{\bf Installation} (\ref{Installation}) 
\item[Bugs]\mbox{}


No fill area.
\end{description}



\newpage



\subsubsection{GMS\_DRIVER\_X11\label{x11}}
\begin{description}
\item[Purpose]\mbox{}


X11 Release 4 and later. Can be configured using 
{\bf X resources} (\ref{XRes}) in a standard fashion.


\item[Minor Modes]\mbox{}


\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_X11 &  110& \\ 
\hline\end{tabular}
\end{center}

\item[Options]\mbox{}


\begin{itemize}
\item  -D display 
\item  -T wintitle 
\item  -X xorigin 
\item  -Y yorigin 
\item  -W winwidth   
\item  -H winheight 
\item  -F X11font 
%\item  -V VisualID
\end{itemize}

\item[Libraries]\mbox{}


-lX11
\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf Workstation Control} (\ref{control}), 
{\bf Compile Time Constants} (\ref{Comp}), 
{\bf Installation} (\ref{Installation}) 
\item[Bugs]\mbox{}


Still some, but together with postscript, in the best state of all.

During opening of the display, gms  tries to find  a true color visual
with the  maximal possible depth, and then  step  by step retries with
less demands on the visual quality.   As visual selection is generally
tricky, this may fail for some reasons.  If a better visual is known 
by its VisualID the use this visual can be forced by setting the
%gms*visualid resource. 
GMS\_VISID environment variable to the appropriate decimal(!) value.

A note for SUSE (and possibly other) Linux users. When configuring the
display using standard tools, e.g.  SaX, because of their conservative
defaults, the default  color depth of the  display may be 8.   In this
case, the  implemented  color allocation   algorithm   may fail
\footnote{
Quote from the XLib Programming Manual:

Note that XAllocColor() works somewhat  differently on dynamic visuals
(such  as PseudoColor)    than  it  does   on  static  visuals   (like
StaticColor).  On dynamic  visuals,   it fails  if  it  is  unable  to
allocate the exact RGB values  requested (i.e., if  there are no  free
cells   and  no cells already    allocated with the   exact RGB values
requested).  On  static visuals, it  returns the cell with the closest
RGB   values.      The algorithm  used    to  determine   "closest" is
server-dependent.   The   moral of  this is  that    a program must be
prepared for XAllocColor() to fail. 

}

  which
results  in graphics becoming  black where it  should  be colored.  We
recommend to choose  a default depth of 16  or 24 which  anyway is the
memory depth which in 1152x864  mode utilizes the huge color resources
of 8MB graphics cards in an adequate way. 


\end{description}



\newpage



\subsubsection{GMS\_DRIVER\_GL\label{gl}}
\begin{description}
\item[Purpose]\mbox{}


SGI Iris Graphics Library. The single buffer mode
makes sense only on  the cheaper boxes, where double buffering
is done via dithering and has a low resolution.
 Makes usage of hardware facilities as transformations,
lighting, Gouraud shading.

\item[Minor Modes]\mbox{}


\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_GL & 200 & \\ 
GMS\_DRIVER\_GL\_SINGLEBUFFER & 200 & single buffer mode\\ 
GMS\_DRIVER\_GL\_DOUBLEBUFFER & 201 & double buffer mode\\ 
\hline\end{tabular}
\end{center}

\item[Options]\mbox{}


\begin{itemize}
\item  -D display 
\item  -T wintitle 
\item  -W winwidth   
\item  -H winheight 
\end{itemize}

\item[Libraries]\mbox{}


-lgl, -lgl\_s
\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf Workstation Control} (\ref{control}), 
{\bf Compile Time Constants} (\ref{Comp}), 
{\bf Installation} (\ref{Installation}) 
\item[Bugs]\mbox{}


Still some.
\end{description}





\newpage



\subsubsection{GMS\_DRIVER\_SUNVIEW\label{sunview}}
\begin{description}
\item[Purpose]\mbox{}


Sun Sunview. For obvious reasons, this will be not 
supported anymore. On Suns, use X11 or ... your sysadmin!
\item[Minor Modes]\mbox{}


\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_GMS\_DRIVER\_SUNVIEW & 140 & \\ 
\hline\end{tabular}
\end{center}

\item[Options]\mbox{}


none
\item[Libraries]\mbox{}


-lsuntool -lsunwindow -lpixrect
\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf Workstation Control} (\ref{control}), 
{\bf Compile Time Constants} (\ref{Comp}), 
{\bf Installation} (\ref{Installation}) 
\item[Bugs]\mbox{}


Quite a few.
\end{description}



\newpage



\subsubsection{GMS\_DRIVER\_POSTSCRIPT\label{ps}}
\begin{description}
\item[Purpose]\mbox{}


Adobe Postscript (tm) output.
It generates fully PS-Adobe-2.0 compliant Encapsulated Postscript 
files for usage with dvips and other programs.
\item[Minor Modes]\mbox{}


\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_POSTSCRIPT &  120& \\ 
GMS\_DRIVER\_POSTSCRIPT\_COLOR &  120& use setrgbcolor \\ 
GMS\_DRIVER\_POSTSCRIPT\_MONO &  121& use setgray\\ 
\hline\end{tabular}
\end{center}

\item[Options]\mbox{}


\begin{itemize}
\item  -O outputfile
\item  -T title (epsf \%\%Title)
\item  -X xorigin   
\item  -Y yorigin 
\end{itemize}

\item[Libraries]\mbox{}


none
\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf Workstation Control} (\ref{control}), 
{\bf Compile Time Constants} (\ref{Comp}), 
{\bf Installation} (\ref{Installation}) 
\item[Bugs]\mbox{}


Still some with paper size management, but together with X11, 
in the best state of all.
\end{description}



\newpage



\subsubsection{GMS\_DRIVER\_HPGL\label{hpgl}}
\begin{description}
\item[Purpose]\mbox{}


HPGL Plotter language.
\item[Minor Modes]\mbox{}


\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_HPGL &  150& \\ 
\hline\end{tabular}
\end{center}

\item[Options]\mbox{}


-O outputfile
\item[Libraries]\mbox{}


non
\item[Bugs]\mbox{}


This driver is in test state.   
\end{description}



\newpage



\subsubsection{GMS\_DRIVER\_MSC\label{msc}}
\begin{description}
\item[Purpose]\mbox{}


Microsoft C graphical interface
\item[Minor Modes]\mbox{}


\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_MSC &  160& \\ 
\hline\end{tabular}
\end{center}

\item[Options]\mbox{}


none
\item[Libraries]\mbox{}


graph or what else is installed  and
file helvb.fon
\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf Workstation Control} (\ref{control}), 
{\bf Compile Time Constants} (\ref{Comp}), 
{\bf Installation} (\ref{Installation}) 
\item[Bugs]\mbox{}


This driver is in test state.   
\end{description}



\newpage



\subsubsection{GMS\_DRIVER\_BGI\label{bgi}}
\begin{description}
\item[Purpose]\mbox{}


Borland C graphical interface
\item[Minor Modes]\mbox{}


\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol & Value& Description\\ 
GMS\_DRIVER\_BGI &  130& \\ 
\hline\end{tabular}
\end{center}

\item[Options]\mbox{}


none
\item[Libraries]\mbox{}


graph or what else is installed  and
file helvb.fon
\item[Related Information]\mbox{}


{\bf gms\_open} (\ref{gmsopen}), 
{\bf Workstation Control} (\ref{control}), 
{\bf Compile Time Constants} (\ref{Comp}), 
{\bf Installation} (\ref{Installation}) 
\item[Bugs]\mbox{}


This driver is in test state.   

\end{description}



\newpage



\section{Miscellaneous Stuff\label{Xrefpages}}

\subsubsection{Compile Time Constants\label{Comp}}These compile time constants shall be specified on 
the command line of the C compiler.

\begin{center}
\begin{tabular}{lll}\hline
Preprocessor Symbol& Default& Description\\ 
NOPROTO &  undef & disable prototyping (pre-ANSI-compilers)\\ 
REAL4 &  undef & generate REAL*4 FORTRAN interface\\ 
WSTABLESIZE &  5 & maximum number of workstations\\ 
FILLSIZE &  64 & maximum size of gms\_fill arguments\\ 
DEFAULTSET &  def & compile all drivers which demand no furtherlibraries\\ 
NODEFAULTSET &  undef & compile no default set of drivers\\ 
POSTSCRIPT &  def & compile postscript driver\\ 
HPGL &  def & compile HPGL driver\\ 
TEK &  def & compile TEK driver\\ 
REGIS &  def & compile REGIS driver\\ 
X11 &  undef & compile X11 driver\\ 
GL &  undef & compile IRIS GL driver\\ 
BGI &  undef & compile BGI driver\\ 
SUNVIEW &  undef & compile SUNVIEW driver\\ 
MSC &  undef & compile MSC driver\\ 
FORTRAN &  undef & appearance of fortran symbols\\ 
FORTRAN\_ &  undef & appearance of fortran symbols\\ 
fortran &  undef & appearance of fortran symbols\\ 
fortran\_ &  def & appearance of fortran symbols\\ 
\hline\end{tabular}
\end{center}



\newpage



\subsubsection{Environment Symbols\label{Env}}The following environment symbols are recognized by {\em GMS\/}:
\begin{center}
\begin{tabular}{lll}\hline
Symbol & Default& Description\\ 
GMSFONT & none & font file name\\ 
GMSERROR & stderr& error output file name\\ 
GMSDEVICE& none & driver number when device=0 in gms\_open\\ 
GMSCONNID& none & connection descriptor when conndsc==NULL in gms\_open\\ 
DISPLAY & ``:0.0''& X11 display\\ 
BGIPATH & none & path to BGI files\\ 
\hline\end{tabular}
\end{center}



\newpage



\subsubsection{X11 Resources\label{XRes}}The following X11 resource strings 
are recognized by {\em GMS\/} and affect only the X11 driver:
\begin{description}
\item[*backingstore (server)]\mbox{}


A value of 'client' forces {\em GMS\/} to draw on a 
background pixmap. This proved to be  when the 
window contents is not saved by the X11 server when
the window is overlapped. On some systems this causes
serious performance drawbacks.
\item[*wait4expose (no)]\mbox{}

 A value of 'yes' lets {\em GMS\/} wait 
for the appearance of the window on the screen before
allowing you to draw anything.
             
\item[*background (white)]\mbox{}

 Specify the name of the background color.

\item[colors (64)]\mbox{}

 Specify the maximum number of read-only color cells
to be used by {\em GMS\/}.
\item[font]\mbox{}

 Specify the name of the X11 font to be used by GMS.
The default is the system wide built-in default.
\end{description}





\newpage



\subsubsection{FORTRAN Interface\label{Fortran}}In the following, the Fortran equivalents of the {\em GMS\/} routines
are described. The fictitious data type GREAL is either
REAL*4 or REAL*8, depending on the installation.
See 
{\bf Fortran} (\ref{instFortran}) for the  details.
\begin{description}
 
\item[
{\bf gms\_open} (\ref{gmsopen})]\mbox{}


\begin{verbatim}
      subroutine gmop(iws,idrv,opt)
      integer*4 iws,idrv
      character*(*) opt
\end{verbatim}

{\bf Caution!} You must terminate the character string explicitely 
by '\verb+\+0'
See 
{\bf Fortran} (\ref{instFortran}) for the  details.




\item[
{\bf gms\_close} (\ref{gmsclose})]\mbox{}


\begin{verbatim}
      subroutine gmcl(iws)
      integer*4 iws
\end{verbatim}


\item[
{\bf gms\_begin} (\ref{gmsbegin})]\mbox{}


\begin{verbatim}
      subroutine gmbeg(iws)
      integer*4 iws
\end{verbatim}


\item[
{\bf gms\_end} (\ref{gmsend})]\mbox{}



\begin{verbatim}
      subroutine gmend(iws)
      integer*4 iws
\end{verbatim}


\item[
{\bf gms\_querystate} (\ref{gmsquerystate})]\mbox{}


\begin{verbatim}
      subroutine gmqcl(iws,istate)
      integer*4 iws,istate
\end{verbatim}


\item[
{\bf gms\_flush} (\ref{gmsflush})]\mbox{}


\begin{verbatim}
      subroutine gmflush
\end{verbatim}


\item[
{\bf gms\_hold} (\ref{gmshold})]\mbox{}


\begin{verbatim}
      subroutine gmhold
\end{verbatim}


\item[
{\bf gms\_clear} (\ref{gmsclear})]\mbox{}


\begin{verbatim}
      subroutine gmclr
\end{verbatim}


\item[
{\bf gms\_window} (\ref{gmswindow})]\mbox{}


\begin{verbatim}
      subroutine gmwn(xmin,xmax,ymin,ymax)
      greal xmin,xmax,ymin,ymax
\end{verbatim}


\item[
{\bf gms\_viewport} (\ref{gmsviewport})]\mbox{}


\begin{verbatim}
      subroutine gmvp(xmin,xmax,ymin,ymax)
      greal xmin,xmax,ymin,ymax
\end{verbatim}


\item[
{\bf gms\_moveto} (\ref{gmsmoveto})]\mbox{}


\begin{verbatim}
      subroutine gmmove(x,y)
      greal x,y
\end{verbatim}


\item[
{\bf gms\_lineto} (\ref{gmslineto})]\mbox{}


\begin{verbatim}
      subroutine gmline(x,y)
      greal x,y
\end{verbatim}


\item[
{\bf gms\_text} (\ref{gmstext})]\mbox{}


\begin{verbatim}
      subroutine gmtext(text)
      character*(*) text
\end{verbatim}

{\bf Caution!} You must terminate the character string explicitely 
by '\verb+\+0'
See 
{\bf Fortran} (\ref{instFortran}) for the  details.

\item[
{\bf gms\_aligntext} (\ref{gmsaligntext})]\mbox{}


\begin{verbatim}
      subroutine gmaltx(ixal,iyal)
      integer*4 ixal,iyal
\end{verbatim}

The possible values of idrv you find in 
{\bf gms\_aligntext} (\ref{gmsaligntext}).

\item[
{\bf gms\_marker} (\ref{gmsmarker})]\mbox{}


\begin{verbatim}
      subroutine gmmark(imk)
      integer*4 imk
\end{verbatim}

The possible values of idrv you find in 
{\bf gms\_marker} (\ref{gmsmarker}).

\item[
{\bf gms\_polyline} (\ref{gmspolyline})]\mbox{}


\begin{verbatim}
      subroutine gmpl(n,x,y)
      integer*4 n
      greal x(n),y(n)
\end{verbatim}


\item[
{\bf gms\_fill} (\ref{gmsfill})]\mbox{}


\begin{verbatim}
      subroutine gmfill(n,x,y)
      integer*4 n
      greal x(n),y(n)
\end{verbatim}



\item[
{\bf gms\_shaded\_triangle} (\ref{gmsshadedtriangle})]\mbox{}


\begin{verbatim}
      subroutine gmstr(x,y,f)
      greal x(3),y(3),f(3)
\end{verbatim}



\item[
{\bf gms\_isoline\_triangle} (\ref{gmsisolinetriangle})]\mbox{}


\begin{verbatim}
      subroutine gmitr(x,y,f)
      greal x(3),y(3),f(3)
\end{verbatim}


\item[
{\bf gms\_setisolevels} (\ref{gmssetisolevels})]\mbox{}


\begin{verbatim}
      subroutine gmsilv(n,v)
      integer*4 n
      greal v(n)
\end{verbatim}



\item[
{\bf gms\_setcolor} (\ref{gmssetcolor})]\mbox{}


\begin{verbatim}
      subroutine gmscol(icol)
      integer*4 icol
\end{verbatim}


\item[
{\bf gms\_defcolor} (\ref{gmsdefcolor})]\mbox{}


\begin{verbatim}
      subroutine gmdcol(r,g,b)
      greal r,g,b
\end{verbatim}


\item[
{\bf gms\_querycolors} (\ref{gmsquerycolors})]\mbox{}


\begin{verbatim}
      subroutine gmqcl(ncol)
      integer*4 ncol
\end{verbatim}


\item[
{\bf gms\_setcolorscale} (\ref{gmssetcolorscale})]\mbox{}


\begin{verbatim}
      subroutine gmscsc(n,r,g,b,v)
      integer*4 ncol
      greal r(ncol),g(ncol),b(ncol),v(ncol)
\end{verbatim}


\item[
{\bf gms3\_window} (\ref{gms3window})]\mbox{}


\begin{verbatim}
      subroutine gm3wn(xmin,xmax,ymin,ymax,zmin,zmax)
      greal xmin,xmax,ymin,ymax,zmin,zmax
\end{verbatim}


\item[
{\bf gms3\_perspective} (\ref{gms3perspective})]\mbox{}


\begin{verbatim}
      subroutine gm3per(alpha,beta)
      greal alpha,beta
\end{verbatim}


\item[
{\bf gms3\_moveto} (\ref{gms3moveto})]\mbox{}


\begin{verbatim}
      subroutine gm3mv(x,y,z)
      greal x,y,z
\end{verbatim}


\item[
{\bf gms3\_lineto} (\ref{gms3lineto})]\mbox{}


\begin{verbatim}
      subroutine gm3ln(x,y,z)
      greal x,y,z
\end{verbatim}


\item[
{\bf gms3\_text} (\ref{gms3text})]\mbox{}


\begin{verbatim}
      subroutine gm3txt(text)
      character*(*) text
\end{verbatim}

{\bf Caution!} You must terminate the character string explicitely 
by '\verb+\+0'
See 
{\bf Fortran} (\ref{instFortran}) for the  details.


\item[
{\bf gms3\_triangle} (\ref{gms3triangle})]\mbox{}


\begin{verbatim}
      subroutine gm3tr(x,y,f)
      greal x(3),y(3),f(3)
\end{verbatim}


\item[
{\bf gms3\_shadedtriangle} (\ref{gms3shadedtriangle})]\mbox{}


\begin{verbatim}
      subroutine gm3str(x,y,z)
      greal x(3),y(3),z(3),f(3)
\end{verbatim}

\end{description}
                   

\end{document}
