
/**********************************************************************
 *                                                                    *
 *  I             A          A            S                           *
 *  Institut fuer Angewandte Analysis und Stochastik  Berlin          *
 *                                                                    *
 *  D-10117 Berlin, Mohrenstr. 39                                     *
 *                                                                    * 
 *  This software is distributed in the hope that it will be useful,  *
 *  but WITHOUT ANY WARRANTY; without even the implied  warranty  of  *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.              *
 *                                                                    */

/**
   \file gms.h
   \brief           Graphics Minimal System 
   \authors  
        Juergen Fuhrmann (fuhrmann@wias-berlin.de)
	Hartmut Langmach (langmach@wias-berlin.de
	Ingo Bremer (bremer@wias-berlin.de)


   Provide a portable interface to different graphical
   environments.
   
   This interface should not include all features one
   could imagine, but a sufficient set of graphics
   routines which could be connected to all the graphics
   systems normally used.

   So it is intended to be used as an on-line graphics tool.
   Perfect presentation graphics should be generated by
   other tools.
   However, postscript protocolling of screen output is 
   possible,  and the postscript files are designed to
   be used for dvips and  other programs.


   This system is in the state of developement,
   so it cannot be guaranteed that it does what is 
   declared here.

   Driver state:
                 -  sufficiently supports REGIS, POSTSCRIPT, X11R4, BGI
                 -  partially supports TEK, SUNVIEW, HPGL, Iris GL, MSC
                 -  FORTRAN and C-Interfaces
                 -  K&R compatible ANSI-C - Source 

         
\b Acknowledgements
             - Ilja Schmelzer 
             - Klaus Gaertner 
             - Norbert Strecker 
             - GNUPLOT     
             -  GHOSTSCRIPT (c) Free Software Foundation (generic fonts)
             -  Xlib Programmer's Guide. (X11)

*/

#ifndef GMS_H
#define GMS_H
/*--------------------------------------------------------------------------*/
#include <stdio.h>
/*** CONFIGURATION */
/* !!! Hint !!! 
   All definition changes should be done 
   at the command line of "cc" via "-D..." ("/define=..." on vms).
   No change of the header or source file should be made!
*/

/*** Preprocessor symbols - Compile time*/

/* NOPROTO should be defined if ANSI-C prototyping does not work*/
/* REAL4   generates a REAL*4 fortran binding                   */
#   ifdef REAL4      
#    define real float
#   else 
#    define real double
#   endif

/* FILLSIZE  defines buffersize for fill area */
#   ifndef FILLSIZE   
#    define FILLSIZE 64
#   endif

/* WSTABLESIZE defines the maximum number of open workstations */
#  ifndef WSTABLESIZE 
#   define WSTABLESIZE 20
#  endif

/* (NO)DEFAULTSET enables the default workstation set - all 
   drivers which don't need  any  libraries besides -lc (VAXCRTL.OLB) */
#  ifndef NODEFAULTSET
#    define DEFAULTSET
#  endif

#  ifdef DEFAULTSET     
#    define POSTSCRIPT
#    define HPGL
#    define TEK
#    define REGIS
#  endif

/* Further implemented drivers - they need specific libraries:
X11 
GL
BGI 
SUNVIEW 
*/ 

/* XMAX_COLORS defines the maximum number of colors allocated
   by one X11 window
*/
# ifndef XMAX_COLORS
#   define XMAX_COLORS 64
#  endif

/* internal string buffer size */
# ifndef GMS_BUFLEN
# define GMS_BUFLEN 256
# endif


/* Switch off ANSI-C Prototyping
NOPROTO
*/

/* How Fortran compilers generate symbols:

     call fortran 

in the fortran source generates  on your system
a reference to an external symbol

   FORTRAN  (all uppercase)
or 
   FORTRAN_ (all uppercase + underscore)
or
   fortran_ (all lowercase + underscore  (unix default, built in))
or
   fortran  (all lowerase  (VMS default, built in)).


Accordingly to this, define FORTRAN, FORTRAN_, fortran or fortran_
to get the right fortran interface.


*/



/**** Environment symbols - startup time */
/* GMSFONT   - name of font file;         default if not set: system font*/
/* GMSERROR  - name of error output file; default if not set: stderr */
/* GMSDEVICE - driver number (invoked if device==0 in gms_open); no default */
/* GMSCONNID - connection descriptor (invoked if conndsc==NULL in gms_open) */

/* DISPLAY   - name of X11 display (X11 only) */
/* BGIPATH   - BGI file path  (BGI only) */
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
#ifndef FORTRAN_UNIX_DEFAULT
#define FORTRAN_UNIX_DEFAULT
#endif 

#ifdef FORTRAN_UNIX_DEFAULT
#ifdef  FORTRAN 
#undef FORTRAN_UNIX_DEFAULT
#endif
#ifdef  FORTRAN_ 
#undef FORTRAN_UNIX_DEFAULT
#endif
#ifdef  fortran 
#undef FORTRAN_UNIX_DEFAULT
#endif
#endif

#ifdef FORTRAN_UNIX_DEFAULT
#ifndef fortran_
#define fortran_
#endif
#endif

#ifdef FORTRAN_
#define gmop    GMOP_
#define gmcl    GMCL_
#define gmhold  GMHOLD_
#define gmflush GMFLUSH_
#define gmbeg   GMBEG_
#define gmend   GMEND_
#define gmclr   GMCLR_
#define gmline  GMLINE_
#define gmmove  GMMOVE_
#define gmpl    GPL_
#define gmmark  GMMARK_
#define gmtext  GMTEXT_
#define gmfill  GMFILL_
#define gmwn    GMWN_
#define gmvp    GMVP_
#define gmscol  GMSCOL_
#define gmdcol  GMDCOL_
#define gmqcl   GMQCL_
#define gmqst   GMQST_
#define gmaltx  GMALTX_
#define gmstr   GMSTR_
#endif

#ifdef FORTRAN
#define gmop    GMOP
#define gmcl    GMCL
#define gmhold  GMHOLD
#define gmflush GMFLUSH
#define gmbeg   GMBEG
#define gmend   GMEND
#define gmclr   GMCLR
#define gmline  GMLINE
#define gmmove  GMMOVE
#define gmpl    GPL
#define gmmark  GMMARK
#define gmtext  GMTEXT
#define gmfill  GMFILL
#define gmwn    GMWN
#define gmvp    GMVP
#define gmscol  GMSCOL
#define gmdcol  GMDCOL
#define gmqcl   GMQCL
#define gmqst   GMQST
#define gmaltx  GMALTX
#define gmstr   GMSTR
#endif

#ifdef fortran_
#define gmop    gmop_
#define gmcl    gmcl_
#define gmhold  gmhold_
#define gmflush gmflush_
#define gmbeg   gmbeg_
#define gmend   gmend_
#define gmclr   gmclr_
#define gmline  gmline_
#define gmmove  gmmove_
#define gmmark  gmmark_
#define gmpl    gmpl_
#define gmtext  gmtext_
#define gmfill  gmfill_
#define gmwn    gmwn_
#define gmvp    gmvp_
#define gmscol  gmscol_
#define gmdcol  gmdcol_
#define gmqcl   gmqcl_
#define gmqst   gmqst_
#define gmaltx  gmaltx_
#define gmstr   gmstr_
#endif

#ifdef fortran
#define gmop    gmop
#define gmcl    gmcl
#define gmhold  gmhold
#define gmflush gmflush
#define gmbeg   gmbeg
#define gmend   gmend
#define gmclr   gmclr
#define gmline  gmline
#define gmmove  gmmove
#define gmmark  gmmark
#define gmpl    gmpl
#define gmtext  gmtext
#define gmfill  gmfill
#define gmwn    gmwn
#define gmvp    gmvp
#define gmscol  gmscol
#define gmdcol  gmdcol
#define gmqcl   gmqcl
#define gmqst   gmqst
#define gmaltx  gmaltx
#define gmstr   gmstr
#endif

#ifndef PARM
#ifdef NOPROTO
#define PARM(list) ()
#else
#define PARM(list) list
#endif
#endif

/*-----------------------------------------------------------------------*/
/*** Workstation Handling*/

void    gmop       PARM((int *ws,int *driver,int  *conndsc));
void    gms_open   PARM(( int  ws,         /* ws identifier                   */
                     int  driver,     /* driver identifier               */ 
                     char *conndsc    /* workstation specific, see below */
                   ));
                   /*  Open and initialize workstation,
                       ascii text output remains possible 
           
                       conndsc can contain the following options:
                       -O fname : name of output file name kernel
                       -D dname : name of X11 display
                       -T tname : X11 window title
                       -H ysize : window size 
                       -W xsize : window size
                       -B colname: name of X11 background color
                       -F fontname: name of X11/PS font (if GMSFONT not set)
                   */
                   /*
                      Hint: All strings taken by the fotran Interface are
                      C strings, so one should write

                        call gmtext('Hi, possums!\0') 
                      instead of
                        call gmtext('Hi, possums!') 
                      
                      Also, if \0 is not recognized by the fortran    
                      compiler, it is analyzed anyway.
                      Under vms, the string descriptor is analyzed,
                      and \0 is taken as terminator, too.
                       
                      So, the fortran code above is really portable.
                      See also tgmsf.f   
                    */


void    gmcl       PARM((int *ws));
void    gms_close  PARM((int  ws));   
                   /* closes  workstation */ 

void    gms_output PARM((int iws, FILE *file));
          /* set output file for next begin/end pair for file devices */
    

void    gmbeg      PARM((int *ws));
void    gms_begin  PARM((int ws));  
                   /*  Enters "graphics mode" of ws;
                       ws<0 -> all opened workstations.
                       ascii text output not guaranteed */

void    gmend      PARM((int *ws));    
void    gms_end    PARM((int ws));    
                   /*  Leave "graphics mode" of ws
                       ws<0 -> all opened workstations.
                       ascii text output will be possible again  */

void    gmhold    PARM((void));   
void    gms_hold  PARM((void));     
                   /* flush output and wait for pressing the  "return"-key 
                      if necessary (picture destroyed with gms_end); */
  
void    gmflush   PARM((void));   
void    gms_flush PARM((void));     
                  /*     flush output    */
  
void    gmclr     PARM((void));
void    gms_clear PARM((void));
                  /*  clear graphics output */

void gms_setaspect(int iws, double asp);
void  gmsas (int *iws,real *asp);
/*--------------------------------------------------------------------------*/
/*** Transformations */
/* GMS virtually knows three coordinate systems, like GKS,
   but has, for simplicity,  only two procedures to manage them:
   - World coordiantes - set by gms_window   (similar to gswn)
   - Normalized device coordinates - set by gms_viewport (similar to gsvp)
   - Device coordinates - not accessible from outside 
*/

void    gmwn      PARM((real *xmin, real *xmax, real *ymin, real *ymax));
void    gms_window PARM((double xmin,
                   double xmax,
                   double ymin,
                   double ymax));

void    gmvp      PARM((real *xmin,real *xmax,real *ymin,real *ymax));
void    gms_viewport PARM((double xmin ,
                  double xmax,
                  double ymin, 
                  double ymax));
                   /* defines NDC Viewport. 
                   [0,1]x[0.1] is the full screen.
                   */
/*--------------------------------------------------------------------------*/
/***Output primitives */
/* besides polyline,
   GMS implements a moveto - lineto model for line drawing */

void    gmmove     PARM((real  *x,real  *y)); 
void    gms_moveto PARM((double x,double y));
                  /*  moves "pen" without drawing */


void    gmline     PARM((real *x ,real  *y));
void    gms_lineto PARM((double x,double y));      
                  /*  moves "pen"  and draws   */

void    gmpl    PARM((int * n, real *x ,real  *y));
void    gms_polyline PARM((int n, real *x,real * y));      
                  /* Polyline Interface to moveto/lineto */


void    gmtext    PARM((int* text));    
void    gms_text  PARM((char* text));             
                 /*   puts aligned text at pen position */

void    gmaltx    PARM((int *xalign, int *yalign));
void    gms_aligntext PARM((int xalign, int yalign));
                  /*  define text alignment with respect to pen position
                      for subsequent text output. 
                      Valid arguments are the following:
                  */

#define GMS_ALIGN_LEFT   1
#define GMS_ALIGN_RIGHT  2
#define GMS_ALIGN_CENTER 3
#define GMS_ALIGN_BOTTOM 1
#define GMS_ALIGN_TOP    2

void    gmmark    PARM((int *mktype));           
void    gms_marker PARM((int mktype)); 
                  /* puts marker at pen position 
                     Valid arguments are the following:*/

#define GMS_MARKER_PIXEL        0
#define GMS_MARKER_DIAMOND      1
#define GMS_MARKER_PLUS         2
#define GMS_MARKER_X            3
#define GMS_MARKER_ASTERISK     4
#define GMS_MARKER_UPARROW     11
#define GMS_MARKER_DOWNARROW   12
#define GMS_MARKER_LEFTARROW   13
#define GMS_MARKER_RIGHTARROW  14


void    gmfill    PARM((int *n, real *x ,real  *y));
void    gms_fill  PARM((int n,double* x,double* y));      
                  /*fill area, doesn't use or change actual pen position   */

/*-------------------------------------------------------------------------*/
/***Color */

void    gmscol       PARM((int *colno));    
void    gms_setcolor PARM((int colno));             
                 /* sets actual color index */

void    gmdcol       PARM((real*r, real *g, real *b));    
void    gms_defcolor PARM((double r,double g, double b));             
                 /*  defines  color represention of icol */

void    gms_setcolorscale PARM((int nval, double *r, double *g, double *b,
                                double *v ));

void    gms_setisolevels  PARM((int nlev, double *val));



void    gms_shaded_triangle  PARM((double *xc,double *yc,double *f));
void    gms_isoline_triangle PARM((double *xc,double *yc,double *f));

/*---------------------------------------------------------------*/
/* 3D */
void    gms3_begin PARM((int iws));
void    gms3_window PARM (( double xmin, double xmax,
                            double ymin, double ymax,
                            double zmin, double zmax));
void    gms3_perspective PARM(( double alpha, double beta /* double dist*/));
void    gms3_begin PARM((int iws));
void    gms3_hold PARM((void));
void    gms3_end PARM((int iws));
void    gms3_text PARM((char *txt));
void    gms3_moveto PARM((double x, double y, double z));
void    gms3_lineto PARM((double x, double y, double z));
void    gms3_triangle PARM((double *xc,double *yc,double *f));
void    gms3_shaded_triangle PARM((double *xc,double *yc,double *z, double *v));


/*-------------------------------------------------------------------------*/
/*** Inquiries*/
void    gmqlev    PARM((int *ws, int *ilev));    
int     gms_querylevel PARM((int iws));    
/* inquire level of gms implementation for ws iws.
   
   Level  Functionality
    0     Line graphics, text
    1     color table mode (gms_defcolor, gms_setcolor), fill areas (gms_fill)
    2     True color mode  (gms_color, gms_isocolor_triangle)
    3     3D mode          (gms3_triangle, gms3_lightsource)
    4     interactive mode (gms_querypoint, gms_querystroke,
                            nontrivial functionality of gms_draw)
*/

void    gmqcl    PARM((int *ws, int *icol));    
int     gms_querycolors PARM((int iws));    
                /*inquire number of colors available   
                 (ws=-1 -> min over all open ws)  */

void    gmqtyp    PARM((int *ws, int *icol));    
int     gms_querytype PARM((int iws));    
                /*inquire wstype */

double gms_querycharwidth(int iws);
void   gmqcw(int *iws, real *w);
void    gmqst   PARM((int *iws, int *istat));
int     gms_querystate PARM((int ws));     
                /*inquire state of ws                    */

#define GMS_STATE_CLOSED 0
#define GMS_STATE_OPEN   1
#define GMS_STATE_ACTIVE 2

/*-------------------------------------------------------------------------*/
/*** Input*/
int     gms_querypoint PARM((int iws, double *x, double *y));
                /*inquire point coordinates from a mouse click (x11 required) */

int     gms_queryline PARM((int iws, double *x0, double *y0, double *x1, double *y1));
                /*inquire line coordinates from the mouse (x11 required) */

int     gms_queryrectangle PARM((int iws,double *x0,double *y0,double *x1,double *y1));
                /*inquire rectangle coordinates from the mouse (x11 required) */




/*-------------------------------------------------------------------------*/
/*** DRIVERS */

#define GMS_DRIVER_DEFAULT   0    /* ==> reads environment symbol GMSDEVICE */



#define GMS_DRIVER_REGIS                20  /* Monochrome*/
#define GMS_DRIVER_REGIS_4COLORS        21
#define GMS_DRIVER_REGIS_8COLORS        22
#define GMS_DRIVER_REGIS_16COLORS       23
#define GMS_DRIVER_REGIS_16FREECOLORS   24  /* VT340 */
/* REGIS Terminals via stdout
   conndsc options    : -O outputfile 
   required libraries : none
   driver state       : ok
*/

#define GMS_DRIVER_TEK4014              30
#define GMS_DRIVER_TEK4014_EMU          31  /* needs "enter/leave 
                                               tektronix mode" string, 
                                               i.e. vt340 in tek mode
                                            */
/* TEK4014 via stdout
   conndsc options    : -O outputfile
   required libraries : none
   driver state       : works, without fillarea
*/


#define GMS_DRIVER_X11                 110

/*  X11 R4  
   conndsc options    : -D display -T wintitle 
                        -X xorigin -Y yorigin 
                        -W width   -H height 
                        -F X11font -B X11backgroundcolor
   .Xdefaults         : gms*font, gms*background 
   required libraries : -lX11
   driver state       : ok

*/

  
#define GMS_DRIVER_BGI     130 
/*  Borland's Graphics Interface under MSDOS(Turbo C, Turbo C++)
   conndsc options    : none
   required libraries : graphics
   driver state       : ok
*/

#define GMS_DRIVER_POSTSCRIPT           120 
#define GMS_DRIVER_POSTSCRIPT_COLOR     120 
#define GMS_DRIVER_POSTSCRIPT_MONO      121 
/* Encapsulated postscript output,   PS-Adobe-2.0 compatible
   conndsc options    : -O outputfile -Titile -Xxorigin -Yyorigin
   required libraries : none
   driver state       : ok
*/

#define GMS_DRIVER_SUNVIEW   140
/* SUNVIEW output
   conndsc options    : none
   required libraries : -lsuntool -lsunwindow -lpixrect
   driver state       : may work, not really checked.
*/

#define GMS_DRIVER_HPGL     150
/* HPGL
   conndsc options    : -F
   required libraries : none
   driver state       : may work, not really checked.
*/

#define GMS_DRIVER_MSC     160 
/*  Mirosoft C Compiler under MSDOS,OS/2 ( MSC6.0 ...)
   conndsc options    : none
   required libraries : graph or what else is installed 
                        file helvb.fon
   driver state       : test
*/

#define GMS_DRIVER_GL                  200
#define GMS_DRIVER_GL_SINGLEBUFFER     200
#define GMS_DRIVER_GL_DOUBLEBUFFER     201
/* Iris GL
   conndsc options    : -X,-Y,-T
   required libraries : -lgl_s
   driver state       : test.
*/

/*
Drivers to be expected in new versions:
OS/2 graphics
OpenGL

Drivers to be written by someone:
emTeX with emlins
gnu c VGA drivers
...
*/
/*--------------------------------------------------------------------------*/
#endif /*GMS_H*/


